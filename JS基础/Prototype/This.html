<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script type="text/javascript">
		//this练习
		var name = "222";
		var a = {
			name : "111",
			say : function() {
				console.log(this.name);
			}
		}
		var fun = a.say;
		fun();//222  由于是自执行，没有函数调用所以走预编译环节，预编译环节this指向window
		a.say();//111

		var b = {
			name : "333",
			say : function (fun){
				fun();
			}
		}
		b.say(a.say);//222
		b.say = a.say;
		b.say();//333
		//arguments.callee   指向函数自身的引用
		//fun.caller：用处比较小了解即可
		function test () {
			demo();
		}
		function demo() {
			console.log(dmeo.caller);//返回调用他的函数
		}
		//
		var foo = 123;
		function print() {
			this.foo = 234;
			console.log(foo);
		}
		print();//123
		//下题在执行test（）和new test()的结果各是什么？
		var a = 5;
		function test() {
			a = 0;
			alert(a);//0  0
			alert(this.a);//5  undefind//在new后产生this {}对象，由于此对象上没有a所以是undefined.
			var a;
			alert(a);//0  0
		}

		var bar = {a : "002"};
		function print(){
			bar.a = 'a';
			Object.prototype.b = 'b';
			return function inner(){
				console.log(bar.a);//a
				console.log(bar.b);//b
			}
		}
		print()();//第一次返回inner函数，第二次执行此函数

		//克隆
		var may = {
			name : may,
			sex : boy,
			age : 20,
			hobby : [football,basketball]
		}
		var may1 = {}

		function clone(Origin,Target){
			var target = Target || {};
			for(var proto in may){
				Target.[proto] = Origin[proto];
			}
			return target;
		}
		clone(may, may1);

		//深度克隆
		var obj = {
			name : "abc",
			age : 123,
			card : ['visa', 'master'],
			wife : {
				name : "bcd",
				son : {
					name : "aaa"
				}
			}
		}
		//遍历对象 for(var prop in obj)
		//1.判断是不是原始值 typeof() object
		//2.判断是数组还是对象 instanceoof constructor toString
		//3.建立相应的数组对象
		function deepClone(origin, target){

				var target = target || {},
					toStr = Object.prototype.toSring,
					arrStr = "[object Array]";
				for(var pro in origin){
					if(origin[prop] !== "mull" && typeof(origin[proop]) == 'object'){
						target[prop] = toStr.call(origin[prop]) == arrStr ? [] : {};
						deepClone(origin[porp],target[prop]);
					}else{
						target[prop] = origin[porop];
					}
				}
			}

				//undefined 和 null不能数字进行比较，不会发生隐士类型转换。 
				return target;
		}


		function a () {
			function b () {
				function c () {

				}
				c();
			}
			b();
		}
		a();
	</script>
	
</body>
</html>